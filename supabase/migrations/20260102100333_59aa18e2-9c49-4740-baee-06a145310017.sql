-- Create the merge_notes function that combines two notes
CREATE OR REPLACE FUNCTION public.merge_notes(p_source_id uuid, p_target_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $function$
DECLARE
  v_source_note record;
  v_target_note record;
  v_updated_items text[];
  v_combined_summary text;
BEGIN
  -- Fetch both notes
  SELECT * INTO v_source_note FROM public.clerk_notes WHERE id = p_source_id;
  SELECT * INTO v_target_note FROM public.clerk_notes WHERE id = p_target_id;
  
  IF v_source_note.id IS NULL THEN
    RAISE EXCEPTION 'Source note not found: %', p_source_id;
  END IF;
  
  IF v_target_note.id IS NULL THEN
    RAISE EXCEPTION 'Target note not found: %', p_target_id;
  END IF;
  
  -- Combine items: add source summary as a new item with "Update:" prefix
  v_updated_items := COALESCE(v_target_note.items, ARRAY[]::text[]);
  v_updated_items := array_append(v_updated_items, 'Update: ' || v_source_note.summary);
  
  -- If source has items, add them too
  IF v_source_note.items IS NOT NULL AND array_length(v_source_note.items, 1) > 0 THEN
    v_updated_items := v_updated_items || v_source_note.items;
  END IF;
  
  -- Merge media URLs if any
  IF v_source_note.media_urls IS NOT NULL AND array_length(v_source_note.media_urls, 1) > 0 THEN
    UPDATE public.clerk_notes
    SET media_urls = COALESCE(media_urls, ARRAY[]::text[]) || v_source_note.media_urls
    WHERE id = p_target_id;
  END IF;
  
  -- Update target note with combined items
  UPDATE public.clerk_notes
  SET 
    items = v_updated_items,
    updated_at = now()
  WHERE id = p_target_id;
  
  -- Archive (soft delete) the source note by marking as completed and adding archive tag
  -- We use completed = true and add a tag to indicate it was merged
  UPDATE public.clerk_notes
  SET 
    completed = true,
    tags = COALESCE(tags, ARRAY[]::text[]) || ARRAY['_merged_into_' || p_target_id::text],
    updated_at = now()
  WHERE id = p_source_id;
  
  -- Return the updated target note
  RETURN (
    SELECT jsonb_build_object(
      'id', id,
      'summary', summary,
      'items', items,
      'category', category,
      'priority', priority,
      'due_date', due_date,
      'completed', completed
    )
    FROM public.clerk_notes
    WHERE id = p_target_id
  );
END;
$function$;

-- Add note_embedding column if it doesn't exist (for similarity search)
-- We'll store embeddings generated by the AI for duplicate detection
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_schema = 'public' 
    AND table_name = 'clerk_notes' 
    AND column_name = 'embedding'
  ) THEN
    ALTER TABLE public.clerk_notes ADD COLUMN embedding extensions.vector(1536);
    CREATE INDEX idx_clerk_notes_embedding ON public.clerk_notes 
      USING ivfflat (embedding extensions.vector_cosine_ops) WITH (lists = 100);
  END IF;
END $$;

-- Function to find similar notes using vector similarity
CREATE OR REPLACE FUNCTION public.find_similar_notes(
  p_user_id text,
  p_couple_id uuid,
  p_query_embedding extensions.vector,
  p_threshold float DEFAULT 0.85,
  p_limit int DEFAULT 5
)
RETURNS TABLE(
  id uuid,
  summary text,
  similarity float
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    n.id,
    n.summary,
    (1 - (n.embedding <=> p_query_embedding))::float AS similarity
  FROM public.clerk_notes n
  WHERE n.embedding IS NOT NULL
    AND n.completed = false
    AND (
      (n.author_id = p_user_id AND n.couple_id IS NULL)
      OR (n.couple_id = p_couple_id AND p_couple_id IS NOT NULL)
    )
    AND (1 - (n.embedding <=> p_query_embedding)) > p_threshold
  ORDER BY n.embedding <=> p_query_embedding ASC
  LIMIT p_limit;
END;
$function$;